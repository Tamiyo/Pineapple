#[macro_export]
macro_rules! types {
    (
        $( #[$meta:meta] )*
        $struct_vis:vis struct $struct:ident,

        $( #[$meta2:meta] )*
        $enum_vis:vis enum $enum:ident,

        $( #[$meta3:meta] )*
        $enum_vis2:vis enum $enum2:ident {
            $( $variant:ident($ty:ty) = $offset:expr,)+
        }
    ) => {
        $( #[$meta] )*
        #[repr(transparent)]
        $struct_vis struct $struct {
            pub value: ValueBox<$enum>,
        }

        impl Eq for $struct {}

        impl std::cmp::PartialOrd for $struct {
            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
                let t1 = self.into_inner();
                let t2 = other.into_inner();
                t1.partial_cmp(&t2)
            }
        }

        impl std::hash::Hash for $struct {
            fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
                self.value.boxed.hash(state);
            }
        }

        impl std::fmt::Debug for $struct {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                write!(f, "{:?}", self.into_inner())
             }
        }

        impl $struct {
            pub fn fetch_ty(&self) -> $enum2 {
                let t = self.value.boxed.ty();
                $enum2::from(t)
            }
        }

        impl ValueContainer for $struct {
            type Inner = $enum;

            fn into_inner(self) -> $enum {
                #[doc(hidden)]
                #[allow(non_camel_case_types)]
                enum __value_box_enum_counter {
                    $( $variant ),+
                }

                // Safety: The generated discriminants and their associated variants should be valid, as
                // they are macro generated. As such, when calling `into_inner` the requested type should
                // be valid for the tagged pointer
                unsafe {
                    match self.value.ty() {
                        $(
                            discrim if discrim == __value_box_enum_counter::$variant as _ =>
                                $enum::$variant(ValueBox::into_inner::<$ty>(self.value)),
                        )+
                        _ => panic!("Attempted to create an enum variant from a type that doesn't exist!"),
                    }
                }
            }
        }

        impl From<$enum> for $struct {
            #[inline]
            fn from(variant: $enum) -> Self {
                use ValueInner;

                Self {
                    value: variant.into_tagged_box(),
                }
            }
        }

        impl Eq for $enum {}

        $(
            impl From<$ty> for $struct {
                #[inline]
                fn from(value: $ty) -> Self {
                    use ValueInner;

                    Self {
                        value: $enum::$variant(value).into_tagged_box(),
                    }
                }
            }
        )+

        $( #[$meta2] )*
        #[derive(Debug)]
        $enum_vis enum $enum {
            $( $variant($ty) ),+
        }

        impl ValueInner for $enum {
            fn into_tagged_box(self) -> ValueBox<Self> {
                #[doc(hidden)]
                #[allow(non_camel_case_types)]
                enum __value_box_enum_counter {
                    $( $variant ),+
                }

                match self {
                    $(
                        Self::$variant(value) => ValueBox::new(value, __value_box_enum_counter::$variant as _),
                    )+
                }
            }

            fn from_tagged_box(tagged: ValueBox<$enum>) -> Self {
                // Safety: The discriminants and the enum variants should be synced, as they are all
                // generated by a macro. Therefore, when `tagged`'s discriminant and the current discriminant
                // are the same, the variant should be valid for the data stored at `tagged`
                unsafe {
                    #[doc(hidden)]
                    #[allow(non_camel_case_types)]
                    enum __value_box_enum_counter {
                        $( $variant ),+
                    }

                    match tagged.ty() {
                        $(
                            discrim if discrim == __value_box_enum_counter::$variant as _ =>
                                Self::$variant(ValueBox::into_inner::<$ty>(tagged)),
                        )+

                        discriminant => {
                            #[allow(non_upper_case_globals)]
                            const __tagged_box_total_variants: usize = [$( stringify!($variant) ),+].len();
                            panic!(
                                "The number of variants in `{}` is {}, but a variant by the discriminant of {} was attempted to be created",
                                stringify!($enum),
                                __tagged_box_total_variants,
                                discriminant
                            );
                        }
                    }
                }
            }
        }

        $( #[$meta3] )*
        #[derive(Debug)]
        #[repr(u16)]
        $enum_vis2 enum $enum2 {
            $( $variant = $offset),+
        }

        impl Eq for $enum2 {}

        impl From<u16> for $enum2 {
            fn from(other: u16) -> Self {
                match other {
                    $(
                        $offset => $enum2::$variant,
                    )+
                    _ => panic!("Tried converting a type tag (u16) from a number outside its range")
                }
             }
        }
    };
}

// https://docs.rs/tagged-box/0.1.1/tagged_box/struct.TaggedBox.html#method.into_inner
#[macro_export]
macro_rules! ops {
    (
        $struct_vis:vis struct $struct:ident, $enum_vis:vis enum $enum:ident {
            $(
                $op:ident, $op_lower:ident, $op_sym:tt: [$($variant:ident),*],
            )+
        }
    ) => {
        $(
            impl std::ops::$op for $struct {
                type Output = $struct;

                fn $op_lower(self, other: Self) -> Self {
                    let t1 = self.into_inner();
                    let t2 = other.into_inner();

                    let t3 = t1 $op_sym t2;

                    Value::from(t3)
                }
            }

            impl std::ops::$op for $enum {
                type Output = $enum;

                fn $op_lower(self, other: Self) -> Self {
                    match (self, other) {
                        $(
                            ($enum::$variant(a), $enum::$variant(b)) => $enum::$variant(a $op_sym b),
                        )*
                        _ => panic!(format!("cannot {:?} {:?} and {:?}", stringify!($op) as &str, self, other))
                    }
                 }
            }
        )+
    };
}

#[macro_export]
macro_rules! implicit_cast_rules {
    (
        $struct_vis:vis struct $struct:ident, $enum_vis:vis enum $enum:ident, $enum_vis2:vis enum $enum2:ident {
            $($variant_from:ident : [$($variant_to:ident($ty:ty)),*],)*
        }
    ) => {
        impl $struct {
            pub fn try_implicit_cast(&mut self, cast_ty: $enum2) -> Result<(), ()> {
                match (self.into_inner(), cast_ty) {
                    $(
                        $(
                            ($enum::$variant_from(t), $enum2::$variant_to) => {
                                *self = $struct::from(t as $ty);
                                Ok(())
                            }
                        )*
                    )+
                    _ => Err(())
                }

            }

            pub fn implicit_cast_unchecked(self, cast_ty: $enum2) -> Self {
                match (self.into_inner(), cast_ty) {
                    $(
                        $(
                            ($enum::$variant_from(t), $enum2::$variant_to) => {
                                $struct::from(t as $ty)
                            }
                        )*
                    )+
                    _ => panic!("")
                }

            }
        }
    };
}

#[macro_export]
macro_rules! explicit_cast_rules {
    (
        $struct_vis:vis struct $struct:ident, $enum_vis:vis enum $enum:ident, $enum_vis2:vis enum $enum2:ident {
            $($variant_from:ident : [$($variant_to:ident($ty:ty)),*],)*
        }
    ) => {
        impl $struct {
            pub fn try_explicit_cast(&mut self, cast_ty: $enum2) -> Result<(), ()> {
                match (self.into_inner(), cast_ty) {
                    $(
                        $(
                            ($enum::$variant_from(t), $enum2::$variant_to) => {
                                *self = $struct::from(t as $ty);
                                Ok(())
                            }
                        )*
                    )+
                    _ => Err(())
                }

            }

            pub fn can_explicit_cast(ty1: $enum2, ty2: $enum2) -> bool {
                match (ty1, ty2) {
                    $(
                        $(
                            ($enum2::$variant_from, $enum2::$variant_to) => {
                                true
                            }
                        )*
                    )+
                    _ => false
                }

            }

            pub fn explicit_cast_unchecked(self, cast_ty: $enum2) -> Self {
                match (self.into_inner(), cast_ty) {
                    $(
                        $(
                            ($enum::$variant_from(t), $enum2::$variant_to) => {
                                $struct::from(t as $ty)
                            }
                        )*
                    )+
                    _ => panic!("")
                }

            }
        }
    };
}
